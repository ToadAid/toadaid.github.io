<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Toadgang Identity ‚Äî Forge Agent (MPASS Gate)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
           background:#0b0f14; color:#e7eef7; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 28px 18px 60px; }
    h1 { font-size: 22px; margin: 0 0 10px; }
    .sub { color:#9fb0c3; font-size: 13px; margin-bottom: 18px; line-height: 1.45; }
    .grid { display:grid; grid-template-columns: 1.2fr 0.8fr; gap:16px; }
    .card { background:#101823; border:1px solid #1f2a3a; border-radius: 14px; padding: 14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .tag { font-size:12px; padding: 4px 8px; border-radius: 999px; border:1px solid #2a3a52; color:#bcd0ea; }
    label { display:block; font-size:12px; color:#b7c7da; margin: 10px 0 6px; }
    input, textarea, select {
      width:100%; box-sizing: border-box; border-radius:10px; border:1px solid #26344a;
      background:#0b121b; color:#e7eef7; padding: 10px 11px; font-size: 14px;
    }
    textarea { min-height: 92px; resize: vertical; }
    button {
      border:0; border-radius: 12px; padding: 11px 14px; font-weight: 700;
      background:#2cff9a; color:#062113; cursor:pointer;
    }
    button.secondary { background:#1f2a3a; color:#e7eef7; border:1px solid #2a3a52; }
    button:disabled { opacity:0.55; cursor:not-allowed; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .muted { color:#9fb0c3; }
    .ok { color:#2cff9a; }
    .bad { color:#ff6b6b; }
    .small { font-size:12px; }
    .hr { height:1px; background:#1f2a3a; margin: 12px 0; }
    img { width:100%; border-radius: 12px; border:1px solid #1f2a3a; background:#0b121b; }
    a { color:#8fd3ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Toadgang Identity ‚Äî Forge Agent (MPASS Gate)</h1>
    <div class="sub">
      This page mints an ERC-8004 agent through the <span class="mono">ToadgangRegistryRouter</span> (so the MPASS gate is enforced).
      <br/>
      Gate: <span class="mono">MPASS ERC-20</span> balance ‚â• <span class="mono">1e18</span> (1 token).
    </div>

    <div class="grid">
      <div class="card">
        <div class="row">
          <span class="tag">Network: Base</span>
          <span id="netTag" class="tag">Wallet: ‚Äî</span>
          <span id="gateTag" class="tag">Gate: ‚Äî</span>
        </div>

        <label>Agent URI (recommended: pinned JSON on IPFS)</label>
        <input id="agentUri" class="mono" placeholder="ipfs://bafy... (or leave empty to auto-generate data: URI from the fields below)" />

        <div class="hr"></div>

        <div class="row">
          <button id="btnConnect" class="secondary">Connect (Browser Wallet)</button>
          <button id="btnWalletConnect" class="secondary">Connect (WalletConnect QR)</button>
          <button id="btnForge" disabled>Forge Agent</button>
        </div>

        <div class="hr"></div>

        <div id="status" class="small muted">Ready.</div>

        <div class="hr"></div>

        <div class="small">
          <div><span class="muted">Registry Router:</span> <span class="mono" id="routerAddr"></span></div>
          <div><span class="muted">MPASS:</span> <span class="mono" id="mpassAddr"></span></div>
          <div><span class="muted">ERC-8004 Registry (proxy):</span> <span class="mono" id="registryAddr"></span></div>
          <div><span class="muted">Reputation Router:</span> <span class="mono" id="repAddr"></span></div>
        </div>
      </div>

      <div class="card">
        <label>Optional metadata (used only if Agent URI is empty)</label>

        <label>Name</label>
        <input id="name" value="Toadgang Agent" />

        <label>Description</label>
        <textarea id="desc">MPASS-gated agent identity. The chain records. The pond interprets. ü™ûüåä</textarea>

        <label>Image (IPFS gateway URL or https URL)</label>
        <input id="imageUrl" class="mono" placeholder="https://.../ipfs/<CID>  (or ipfs://CID)" />

        <label>External URL</label>
        <input id="externalUrl" class="mono" placeholder="https://toadaid.github.io" />

        <label>Attributes (JSON array)</label>
        <textarea id="attrs" class="mono">[
  {"trait_type":"Gate","value":"MPASS ‚â• 1"},
  {"trait_type":"Chain","value":"Base"},
  {"trait_type":"Role","value":"Toadgang Identity"}
]</textarea>

        <div class="hr"></div>
        <div class="small muted">
          If you already pinned a JSON file, paste its <span class="mono">ipfs://&lt;CID&gt;</span> in ‚ÄúAgent URI‚Äù and ignore this panel.
        </div>
      </div>
    </div>
  </div>

<script type="module">
  import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.4/+esm";
  import EthereumProvider from "https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.13.0/+esm";

  // Base mainnet
  const BASE_CHAIN_ID = 8453;
  const BASE_PARAMS = {
    chainId: "0x2105",
    chainName: "Base",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: ["https://mainnet.base.org"],
    blockExplorerUrls: ["https://basescan.org"]
  };

  // WalletConnect (QR) ‚Äî set your WC Project ID (cloud.walletconnect.com)
  // You can also set it via:
  //   1) querystring:  ?wc=YOUR_PROJECT_ID
  //   2) localStorage: localStorage.setItem("WC_PROJECT_ID","YOUR_PROJECT_ID")
  const WC_PROJECT_ID =
    new URLSearchParams(location.search).get("wc") ||
    localStorage.getItem("WC_PROJECT_ID") ||
    "";

  // Contracts (Base)
  const ROUTER = "0x17163e5380929b04D4cC24f82aa6AC30877Bd0e0";              // ToadgangRegistryRouter (MPASS gate)
  const MPASS  = "0xdB9e64465d4B5fbc7Ee9091C459094eFC7dF5cdE";              // MPASS ERC-20
  const REGISTRY_PROXY = "0x8004A169FB4a3325136EB29fA0ceB6D2e539a432";       // ERC-8004 registry proxy
  const REP_ROUTER = "0x94D7B431dD8eAFc9E1b71624DF0a90468622537a";           // ToadgangReputationRouter

  // Gate policy (mirror what you set onchain)
  const MIN_BALANCE = 10n ** 18n; // 1e18

  // Minimal ABIs
  const ROUTER_ABI = [
    "function forge(string agentURI) external returns (uint256 agentId)",
    "function paused() view returns (bool)",
    "function gateToken() view returns (address)",
    "function gateType() view returns (uint8)",
    "function minBalance() view returns (uint256)"
  ];
  const ERC20_ABI = ["function balanceOf(address) view returns (uint256)"];

  // UI
  const $ = (id) => document.getElementById(id);
  const netTag = $("netTag");
  const gateTag = $("gateTag");
  const status = $("status");
  $("routerAddr").textContent = ROUTER;
  $("mpassAddr").textContent = MPASS;
  $("registryAddr").textContent = REGISTRY_PROXY;
  $("repAddr").textContent = REP_ROUTER;

  // Insert quick WC hint in status if missing Project ID
  function wcHint() {
    if (WC_PROJECT_ID) return "";
    return " WalletConnect disabled (missing WC Project ID).";
  }

  let provider, signer, user;
  let wcProvider = null; // WalletConnect EthereumProvider

  function setStatus(msg, cls="muted") {
    status.className = "small " + cls;
    status.textContent = msg;
  }

  function toHttpIfIpfs(uri) {
    if (!uri) return uri;
    if (uri.startsWith("ipfs://")) {
      const cid = uri.replace("ipfs://", "");
      return `https://ipfs.io/ipfs/${cid}`;
    }
    return uri;
  }

  function buildDataUriFromFields() {
    const name = $("name").value.trim();
    const description = $("desc").value.trim();
    const imageRaw = $("imageUrl").value.trim();
    const image = toHttpIfIpfs(imageRaw);
    const external_url = $("externalUrl").value.trim();

    let attributes = [];
    try { attributes = JSON.parse($("attrs").value || "[]"); } catch { attributes = []; }

    const obj = { name, description, image };
    if (external_url) obj.external_url = external_url;
    if (Array.isArray(attributes) && attributes.length) obj.attributes = attributes;

    const json = JSON.stringify(obj);
    const b64 = btoa(unescape(encodeURIComponent(json)));
    return `data:application/json;base64,${b64}`;
  }

  async function refreshGateStatus() {
    if (!provider || !user) return;

    const router = new ethers.Contract(ROUTER, ROUTER_ABI, provider);
    const paused = await router.paused();
    const gateToken = await router.gateToken();
    const minBal = await router.minBalance();

    // Basic sanity: router is configured to our MPASS + 1e18
    const configuredOk = (gateToken.toLowerCase() === MPASS.toLowerCase()) && (minBal === MIN_BALANCE);

    const mpass = new ethers.Contract(MPASS, ERC20_ABI, provider);
    const bal = await mpass.balanceOf(user);

    const hasGate = bal >= MIN_BALANCE;

    // Tags
    netTag.textContent = `Wallet: ${user.slice(0,6)}‚Ä¶${user.slice(-4)}`;
    gateTag.textContent = paused
      ? "Gate: router paused"
      : hasGate
        ? "Gate: MPASS OK"
        : "Gate: need MPASS";

    $("btnForge").disabled = paused || !hasGate;

    if (!configuredOk) {
      setStatus("Warning: router gate config onchain doesn't match expected MPASS + 1e18.", "bad");
      return;
    }

    if (paused) setStatus("Router is paused. Unpause via Safe before forging.", "bad");
    else if (!hasGate) setStatus("This wallet does not meet the MPASS gate (need ‚â• 1e18).", "bad");
    else setStatus("Gate satisfied. Ready to forge." + wcHint(), "ok");
  }

  async function connectInjected() {
    const eth = window.ethereum;
    if (!eth) throw new Error("No browser wallet found. Install MetaMask / Rabby, or use WalletConnect.");
    const chainIdHex = await eth.request({ method: "eth_chainId" });
    const chainId = Number(chainIdHex);
    if (chainId !== BASE_CHAIN_ID) {
      try {
        await eth.request({ method: "wallet_switchEthereumChain", params: [{ chainId: BASE_PARAMS.chainId }] });
      } catch (e) {
        await eth.request({ method: "wallet_addEthereumChain", params: [BASE_PARAMS] });
      }
    }

    provider = new ethers.BrowserProvider(eth);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    user = await signer.getAddress();
  }

  async function connectWalletConnect() {
    if (!WC_PROJECT_ID) {
      throw new Error("WalletConnect Project ID missing. Add ?wc=YOUR_PROJECT_ID to the URL or set localStorage.WC_PROJECT_ID.");
    }
    wcProvider = await EthereumProvider.init({
      projectId: WC_PROJECT_ID,
      chains: [BASE_CHAIN_ID],
      showQrModal: true,
      rpcMap: {
        [BASE_CHAIN_ID]: "https://mainnet.base.org"
      }
    });

    // Opens QR modal
    await wcProvider.enable();

    provider = new ethers.BrowserProvider(wcProvider);
    signer = await provider.getSigner();
    user = await signer.getAddress();

    // Optional: handle disconnect UI
    wcProvider.on("disconnect", () => {
      provider = null; signer = null; user = null; wcProvider = null;
      netTag.textContent = "Wallet: ‚Äî";
      gateTag.textContent = "Gate: ‚Äî";
      $("btnForge").disabled = true;
      setStatus("Disconnected.", "muted");
    });
  }

  $("btnConnect").onclick = async () => {
    try {
      setStatus("Connecting browser wallet‚Ä¶");
      await connectInjected();
      setStatus("Connected.", "ok");
      await refreshGateStatus();
    } catch (e) {
      console.error(e);
      setStatus((e?.message || String(e)) + wcHint(), "bad");
    }
  };

  // WalletConnect button (QR)
  const btnWC = document.getElementById("btnWalletConnect");
  if (btnWC) {
    btnWC.onclick = async () => {
      try {
        setStatus("Opening WalletConnect‚Ä¶");
        await connectWalletConnect();
        setStatus("Connected (WalletConnect).", "ok");
        await refreshGateStatus();
      } catch (e) {
        console.error(e);
        setStatus(e?.message || String(e), "bad");
      }
    };

    // Disable visually if no project id
    if (!WC_PROJECT_ID) {
      btnWC.disabled = true;
      btnWC.title = "Set WalletConnect Project ID to enable QR connect.";
    }
  }

  $("btnForge").onclick = async () => {
    try {
      if (!signer) throw new Error("Connect wallet first.");
      const router = new ethers.Contract(ROUTER, ROUTER_ABI, signer);

      let agentURI = $("agentUri").value.trim();
      if (!agentURI) agentURI = buildDataUriFromFields();

      setStatus("Submitting forge()‚Ä¶ confirm in wallet.", "muted");
      const tx = await router.forge(agentURI);
      setStatus(`Pending: ${tx.hash}`, "muted");

      const rcpt = await tx.wait();

      // Decode Forged event
      let agentId = null;
      try {
        const iface = new ethers.Interface([
          "event Forged(address indexed user,uint256 indexed agentId,address indexed registry,string agentURI)"
        ]);
        for (const log of rcpt.logs) {
          if (log.address.toLowerCase() !== ROUTER.toLowerCase()) continue;
          try {
            const parsed = iface.parseLog(log);
            if (parsed && parsed.name === "Forged") {
              agentId = parsed.args.agentId;
              break;
            }
          } catch {}
        }
      } catch {}

      const explorer = `https://basescan.org/tx/${tx.hash}`;
      if (agentId !== null) setStatus(`Forged ‚úÖ agentId = ${agentId.toString()} | ${explorer}`, "ok");
      else setStatus(`Forged ‚úÖ | ${explorer}`, "ok");

      await refreshGateStatus();
    } catch (e) {
      console.error(e);
      setStatus(e?.shortMessage || e?.message || String(e), "bad");
    }
  };

  // On load: show WC status hint
  setStatus("Ready." + wcHint(), "muted");
</script>
</body>
</html>

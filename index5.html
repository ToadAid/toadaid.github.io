<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="format-detection" content="telephone=no" />
<style>html{-webkit-text-size-adjust:100%}</style>

<title>ToadAid â€” Guarding the Lore</title>
<meta name="description" content="ToadAid â€” Guarding the Lore. Ask the Mirror for guidance and explore the scrolls of Tobyworld.">

<!-- OG -->
<meta property="og:title" content="ToadAid â€” Guarding the Lore" />
<meta property="og:description" content="Ask the Mirror for guidance. Explore the scrolls of Tobyworld." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://toadaid.github.io" />
<meta property="og:image" content="https://toadaid.github.io/assets/icons/web-app-manifest-512x512.png" />
<link rel="canonical" href="https://toadaid.github.io" />

<!-- Icons -->
<link rel="icon" type="image/x-icon" href="/assets/icons/favicon.ico">
<link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
<link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
<link rel="manifest" href="/assets/icons/site.webmanifest">
<meta name="theme-color" content="#355e3b" />

<style>
:root{
  --bg:#f5f1e6; --ink:#2f2f2f; --green:#355e3b;
  --gold:#ffd23f; --gold-ink:#1a1a1a;
  --card:#fff; --chip:#214834; --chip-ink:#eaf3ee;
  --shadow-s:rgba(0,0,0,.08); --shadow-m:rgba(0,0,0,.2);
  --accent-veil:rgba(53,94,59,.08);
}

*{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
body{font-family:'Segoe UI',system-ui,-apple-system,Roboto,Ubuntu,sans-serif;background:var(--bg);color:var(--ink);line-height:1.6;overflow-x:hidden}

/* Banner */
.banner{
  position:relative;width:100%;min-height:260px;
  background:
    linear-gradient(rgba(0,0,0,.12), rgba(0,0,0,.22)),
    url('banner.jpg') center/cover no-repeat;
  display:flex;flex-direction:column;justify-content:center;align-items:center;
  text-align:center;color:#fff;padding:1.2rem 1rem;box-shadow:0 2px 10px var(--shadow-m);
}
@media (min-width:768px){ .banner{min-height:360px} }
.banner h1{font-size:clamp(1.9rem,4.6vw,2.8rem);text-shadow:0 2px 8px rgba(0,0,0,.55);font-weight:700}
.banner p{font-size:clamp(1rem,2.2vw,1.2rem);margin-top:.45rem;text-shadow:0 1px 4px rgba(0,0,0,.45)}

/* Translate bar & buttons */
.translate-bar{background:var(--gold);color:var(--gold-ink);padding:.65rem 1rem;text-align:center;font-weight:700}
.btn{
  display:inline-flex;align-items:center;gap:.55rem;background:var(--gold);color:var(--gold-ink);
  padding:.7rem 1.1rem;margin:.35rem;border:0;border-radius:12px;font-weight:800;
  box-shadow:0 3px 8px var(--shadow-m);cursor:pointer;text-decoration:none;transition:transform .15s ease, box-shadow .15s ease
}
.btn:hover{transform:translateY(-1px);box-shadow:0 6px 12px var(--shadow-m)}
.btn-dark{background:var(--chip);color:var(--chip-ink)}
.btn-green{background:#2e6d4c;color:#fff}
.btn-deep{background:#265c40;color:#fff}
.btn-library{background:#3a7253;color:#fff}

section{padding:2rem 1rem;max-width:1200px;margin:auto}
h2{text-align:center;margin-bottom:1.1rem;color:var(--green)}
.pillars{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:1rem;margin-top:.6rem}
.pillar{background:var(--card);padding:1rem;border-radius:12px;box-shadow:0 2px 8px var(--shadow-s);border:1px solid rgba(0,0,0,.06);color:inherit}

/* Mirror section container + input + chips */
#mirror{background:linear-gradient(135deg,#f5f1e6,#e8e0d0);border-radius:16px;box-shadow:0 6px 16px var(--shadow-s);margin:2rem 1rem}
.mirror-wrap{max-width:860px;margin:auto;padding:1.5rem}
#mirror-question{
  width:100%;padding:1rem 1.2rem;border-radius:12px;border:2px solid #d7ddd7;background:#fff;font-size:16px;
  box-shadow:0 1px 2px rgba(0,0,0,.04) inset;
}
#mirror-question:focus{outline:none;border-color:var(--green);box-shadow:0 0 0 3px rgba(53,94,59,.12)}
.sugs{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;margin:.9rem 0}
.chip{background:var(--accent-veil);border:1px solid rgba(53,94,59,.25);padding:.5rem .9rem;border-radius:22px;font-weight:700;cursor:pointer}
.chip:hover{background:rgba(53,94,59,.18)}

/* Seek Wisdom bar */
.cta{
  width:100%;padding:1rem 1.2rem;border:0;border-radius:12px;
  background:linear-gradient(135deg,#6b5bd2,#7b4aa2);color:#fff;
  font:600 1.05rem/1 system-ui,-apple-system,"Segoe UI",sans-serif;
  display:flex;align-items:center;justify-content:center;gap:.6rem;text-align:center;
  box-shadow:0 6px 12px var(--shadow-s);cursor:pointer;
}
#ask-label{display:inline-block}
#ask-spinner{display:none}
.loading-ripple{position:relative;width:18px;height:18px}
@keyframes ripple{0%{transform:scale(.8);opacity:1}100%{transform:scale(2.4);opacity:0}}
.loading-ripple div{position:absolute;border:2px solid #fff;border-radius:50%;animation:ripple 1s cubic-bezier(0,.2,.8,1) infinite}
.loading-ripple div:nth-child(2){animation-delay:-.5s}

/* Dialogue cards */
.mirror-dialogue{background:#fff;border-left:4px solid var(--green);border-radius:12px;box-shadow:0 4px 12px var(--shadow-s);padding:1.1rem;margin-top:1rem;opacity:0;transform:translateY(14px);transition:all .3s ease}
.mirror-dialogue.visible{opacity:1;transform:translateY(0)}
.user-question{background:#edf0ec;border-left:4px solid #d4af37;border-radius:10px;padding:.9rem 1rem;margin:.4rem .4rem 1rem;font-style:italic}
.mirror-response{line-height:1.75}
.mirror-greeting{color:var(--green);font-weight:700;margin:.5rem 0 1rem}
.wisdom-point{background:rgba(212,175,55,.12);border-left:3px solid #d4af37;border-radius:10px;padding:.9rem 1rem;margin:1rem 0}
.wisdom-point strong{color:var(--green);display:block;margin-bottom:.35rem}
.wisdom-paragraph{margin:.7rem 0}
.guiding-question{background:rgba(53,94,59,.06);border-left:3px solid var(--green);border-radius:10px;padding:.9rem 1rem;margin:1.2rem 0 .8rem;font-style:italic;color:#2f2f2f}
.guiding-question strong{color:var(--green);font-style:normal}
.symbols-line{text-align:center;letter-spacing:.18em;opacity:.85;margin:1rem 0}
.mirror-signature{opacity:.75;text-align:right;margin-top:1rem;font-style:italic;color:var(--green)}
.error-message{background:rgba(244,67,54,.1);border-left:4px solid #f44336;border-radius:10px;padding:1rem;margin-top:1rem}

/* Voice Controls */
.voice-controls {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 1rem 0 0.5rem 0;
  padding: 0.8rem;
  background: rgba(53, 94, 59, 0.05);
  border-radius: 10px;
  border-left: 3px solid var(--green);
}

.voice-btn {
  background: var(--green);
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  transition: all 0.2s ease;
}

.voice-btn:hover {
  background: #2a4a2f;
  transform: translateY(-1px);
}

.voice-btn:disabled {
  background: #cccccc;
  cursor: not-allowed;
  transform: none;
}

.voice-btn.playing {
  background: #2196F3;
}

.voice-select {
  padding: 4px 8px;
  border-radius: 8px;
  border: 1px solid #ddd;
  background: white;
  font-size: 12px;
}

.voice-status {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 4px;
  margin-left: auto;
}

.voice-status.generating {
  background: #fff3cd;
  color: #856404;
}

.voice-status.error {
  background: #f8d7da;
  color: #721c24;
}

.voice-status.playing {
  background: #d1ecf1;
  color: #0c5460;
}

.voice-status.mobile-tap {
  background: #d4edda;
  color: #155724;
}

.pulse-dot {
  width: 8px;
  height: 8px;
  background: white;
  border-radius: 50%;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}

footer{background:var(--green);color:#fff;text-align:center;padding:2rem 1rem;margin-top:2rem}
footer a{color:#ffd23f;font-weight:800}

@media (max-width:720px){
  section{padding:1.6rem 1rem}
  #mirror{margin:1.2rem 0}
  .voice-controls {
    flex-wrap: wrap;
    justify-content: center;
  }
  .voice-status {
    margin-left: 0;
    margin-top: 5px;
    width: 100%;
    text-align: center;
  }
}
</style>
</head>
<body>

<!-- Banner -->
<div class="banner">
  <h1>ğŸ¯ ToadAid â€” Guarding the Lore</h1>
  <p>One scroll, one light. One leaf, one vow.</p>
</div>

<div class="translate-bar">
  ğŸŒ Want to read in your language? In Chrome: Menu (â‹®) â†’ Translate â†’ Select your language.
</div>

<section style="text-align:center">
  <a href="/Mirror" class="btn">ğŸª Mirror</a>
  <a href="/Speculation/" class="btn">ğŸ”® Speculation</a>
  <a href="bluepaper.html" class="btn">ğŸ“„ Blue Paper</a>
  <a href="about.html" class="btn">ğŸ“˜ About ToadAid</a>
  <a href="feedback/feedback.html" class="btn">ğŸ’¬ Feedback</a>

  <div style="margin-top:.4rem">
    <a href="Contributors/contributors.html" class="btn btn-dark">ğŸ¸ Contributors</a>
    <a href="builders/builders-hall.html" class="btn btn-dark">ğŸ› Builders Hall</a>
    <a href="https://toadaid-builders.netlify.app/builders.html" class="btn btn-dark" target="_blank">ğŸ›  Builders</a>
    <a href="honors/index.html" class="btn btn-dark">ğŸ¸ Honors & Offerings</a>
    <a href="scrolls/index.html" class="btn btn-dark">ğŸ“œ Scroll Vault</a>
    <a href="https://toadaid.github.io/lore" class="btn btn-dark">ğŸ“– Lore Library</a>
  </div>
</section>

<!-- Mirror -->
<section id="mirror">
  <h2>ğŸ”® Ask the Mirror</h2>
  <div class="mirror-wrap">
    <input id="mirror-question" type="text" placeholder="What wisdom do you seek today, traveler?" autocomplete="off">
    <div class="sugs">
      <button class="chip" onclick="fillQuestion('How do I find inner peace?')">ğŸŒ¿ Inner Peace</button>
      <button class="chip" onclick="fillQuestion('What is true community?')">ğŸ¸ True Community</button>
      <button class="chip" onclick="fillQuestion('What does silence teach us?')">ğŸŒ€ Silence Wisdom</button>
      <button class="chip" onclick="fillQuestion('How do I overcome fear?')">ğŸ’« Overcoming Fear</button>
    </div>

    <button id="mirror-ask-btn" class="btn cta" onclick="askMirror()">
      <span class="loading-ripple" id="ask-spinner"><div></div><div></div></span>
      <span id="ask-label">Seek Wisdom</span>
    </button>

    <div id="mirror-answer"></div>
  </div>
</section>

<!-- Lore -->
<section id="lore">
  <h2>ğŸ“š Lore Library</h2>
  <div class="pillars">
    <a href="bluepaper.html" class="pillar" target="_blank">
      <h3>ğŸ“„ Bluepaper</h3>
      <p>The updated mission, vision, and principles of ToadAid.</p>
    </a>
    <a href="#" class="pillar" onclick="openBook('v1.html')">
      <h3>ğŸ“œ Book v1</h3>
      <p>The first collected scrolls of Tobyworld lore. Bilingual EN/ZH edition.</p>
    </a>
    <a href="#" class="pillar" onclick="openBook('v2.html')">
      <h3>ğŸ“œ Book v2</h3>
      <p>The expanded lore, with Mirror awakening & new revelations.</p>
    </a>
  </div>
</section>

<!-- Children -->
<section id="children">
  <h2>ğŸ¸ğŸ“š Children's Corner â€” One Leaf for the Young</h2>
  <p style="text-align:center;max-width:800px;margin:1rem auto;color:#355e3b">
    The flame we guard is for Toby, the People. Every scroll carries truth for the presentâ€¦ and seeds for those who will walk after us.
    Here, the Lore wears softer colors â€” so even the smallest frog can hear its song.
  </p>
  <div style="text-align:center;margin-top:1.4rem">
    <a href="childrens-corner/index.html" class="btn btn-green">ğŸŒ¿ Visit the Children's Corner</a>
  </div>
</section>

<footer>
  <p>"One scroll, one light. One leaf, one vow."</p>
  <p>ğŸ¸ Join us:
    <a href="https://t.me/Toadgang" target="_blank">Telegram</a> |
    <a href="https://github.com/ToadAid" target="_blank">GitHub</a> |
    <a href="https://x.com/toadgod1017" target="_blank">Toadgod on X</a> |
    <a href="https://toadgod.xyz" target="_blank">Toadgod.xyz</a>
  </p>
</footer>

<script>
/* ========== MOBILE DETECTION ========== */
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

/* ========== VOICE SERVICE ========== */
class VoiceService {
  constructor() {
    this.baseURL = 'https://toadaid.duckdns.org/v7/voice';
    this.isPlaying = false;
    this.currentAudio = null;
  }

  async generateSpeech(text, voiceProfile = 'pond_guide') {
    try {
      const response = await fetch(`${this.baseURL}/whisper`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text, voice_profile: voiceProfile, include_ambience: true })
      });

      if (!response.ok) throw new Error(`Voice API error: ${response.status}`);
      return await response.json();
    } catch (error) {
      console.error('Voice generation failed:', error);
      throw error;
    }
  }

  async playAudio(base64Audio) {
    this.stopAudio();
    
    try {
      const audioBlob = this.base64ToBlob(base64Audio, 'audio/mpeg');
      const audioUrl = URL.createObjectURL(audioBlob);
      
      this.currentAudio = new Audio(audioUrl);
      this.isPlaying = true;
      
      // âœ… MOBILE FIX: Handle mobile browser audio restrictions
      return new Promise((resolve, reject) => {
        const playPromise = this.currentAudio.play();
        
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              console.log("ğŸµ Audio playing successfully");
            })
            .catch(error => {
              console.error("ğŸµ Audio play failed:", error);
              this.isPlaying = false;
              URL.revokeObjectURL(audioUrl);
              
              // Mobile browsers require explicit user gesture
              if (isMobileDevice()) {
                reject(new Error("Tap again to play audio"));
              } else {
                reject(new Error("Audio playback requires user interaction"));
              }
            });
        }
        
        this.currentAudio.onended = () => {
          this.isPlaying = false;
          URL.revokeObjectURL(audioUrl);
          resolve();
        };
        
        this.currentAudio.onerror = (error) => {
          this.isPlaying = false;
          URL.revokeObjectURL(audioUrl);
          reject(error);
        };
      });
    } catch (error) {
      console.error('Audio playback failed:', error);
      throw error;
    }
  }

  stopAudio() {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio.currentTime = 0;
      this.isPlaying = false;
    }
  }

  base64ToBlob(base64, mimeType) {
    const byteCharacters = atob(base64);
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += 512) {
      const slice = byteCharacters.slice(offset, offset + 512);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      byteArrays.push(new Uint8Array(byteNumbers));
    }
    return new Blob(byteArrays, { type: mimeType });
  }

  async speakText(text, voiceProfile = 'pond_guide') {
    try {
      console.log(`ğŸ¯ Speaking: "${text}" with voice: ${voiceProfile}`);
      const audioData = await this.generateSpeech(text, voiceProfile);
      await this.playAudio(audioData.audio_base64);
      return { success: true, duration: audioData.duration_seconds };
    } catch (error) {
      console.error('Speech failed:', error);
      return { success: false, error: error.message };
    }
  }
}

// Global voice service instance
const voiceService = new VoiceService();

/* ========== VOICE CONTROL FUNCTIONS ========== */
let currentVoiceProfile = 'pond_guide';

function updateVoiceProfile(profile) {
  currentVoiceProfile = profile;
}

async function speakMirrorResponse(button) {
  const voiceControls = button.parentElement;
  const statusEl = voiceControls.querySelector('.voice-status');
  const playIcon = button.querySelector('.play-icon');

  // âœ… MOBILE FIX: Ensure button is in focus for user interaction
  button.focus();

  const text = button.getAttribute('data-text') || "";

  if (!text) {
    console.error("âŒ No text found in data-text!");
    statusEl.textContent = "Error: No text";
    statusEl.className = 'voice-status error';
    return;
  }

  // âœ… 1) If we already have cached audio for this answer, just replay it
  const cachedAudio = button.getAttribute('data-audio');
  if (cachedAudio) {
    console.log("ğŸ”Š Replaying cached audio");
    statusEl.textContent = "Playing...";
    statusEl.className = 'voice-status playing';
    playIcon.textContent = "â¸";
    button.disabled = true;

    try {
      await voiceService.playAudio(cachedAudio);
    } catch (err) {
      console.error("ğŸ”Š Cached audio playback failed:", err);
      
      // âœ… MOBILE FIX: Better error handling for mobile
      if (err.message.includes('Tap again')) {
        statusEl.textContent = "Tap again to play";
        statusEl.className = "voice-status mobile-tap";
      } else {
        statusEl.textContent = "Playback error";
        statusEl.className = "voice-status error";
      }
    } finally {
      resetVoiceControls(voiceControls);
    }
    return;
  }

  // âœ… 2) First time: generate audio, cache it, then play
  const ttsText = "Traveler. " + text.trim();

  console.log("ğŸ”Š Generating new audio via ElevenLabs...");
  statusEl.textContent = "Generating voice...";
  statusEl.className = 'voice-status generating';
  playIcon.textContent = "â¸";
  button.disabled = true;

  try {
    const audioData = await voiceService.generateSpeech(ttsText, currentVoiceProfile);

    if (audioData && audioData.audio_base64) {
      console.log("ğŸ”Š Voice generation complete, caching audio");
      button.setAttribute('data-audio', audioData.audio_base64);

      statusEl.textContent = "Playing...";
      statusEl.className = 'voice-status playing';

      await voiceService.playAudio(audioData.audio_base64);
    } else {
      throw new Error("No audio data received");
    }
  } catch (error) {
    console.error("ğŸ”Š Voice playback failed:", error);
    
    // âœ… MOBILE FIX: Better error messages for mobile
    if (error.message.includes('Tap again')) {
      statusEl.textContent = "Tap again to play";
      statusEl.className = "voice-status mobile-tap";
    } else {
      statusEl.textContent = "Failed: " + error.message;
      statusEl.className = "voice-status error";
    }
  } finally {
    resetVoiceControls(voiceControls);
  }
}

function resetVoiceControls(voiceControls) {
  const button = voiceControls.querySelector('.voice-btn');
  const statusEl = voiceControls.querySelector('.voice-status');
  const playIcon = button.querySelector('.play-icon');
  
  button.disabled = false;
  button.classList.remove('playing');
  playIcon.textContent = 'â–¶';
  
  // âœ… MOBILE FIX: Better status message for mobile
  if (isMobileDevice()) {
    statusEl.textContent = 'Tap to listen';
  } else {
    statusEl.textContent = 'Ready';
  }
  statusEl.className = 'voice-status';
}

/* Books */
function openBook(bookFile){
  const saved = localStorage.getItem(bookFile + '-scroll');
  if(saved && confirm("ğŸ“Œ Last time you stopped at position " + saved + "px. Continue from there?")){
    location.href = bookFile + "?pos=" + saved; return;
  }
  location.href = bookFile;
}

/* ----------------- Mirror logic ----------------- */
const MIRROR_API = "https://toadaid.duckdns.org/ask";
const askBtn = document.getElementById('mirror-ask-btn');
const askSpin = document.getElementById('ask-spinner');
const askLabel = document.getElementById('ask-label');
const qInput = document.getElementById('mirror-question');
const ansDiv = document.getElementById('mirror-answer');

function fillQuestion(q){ qInput.value=q; qInput.focus(); }

/* ========== PERSISTENT USER IDENTITY ========== */
function getStableUserId() {
    let userId = localStorage.getItem('mirror_user_id');
    if (!userId) {
        userId = "web_" + Math.random().toString(36).substr(2, 12);
        localStorage.setItem('mirror_user_id', userId);
    }
    return userId;
}

/* Off-ramp detection: accepts with/without emoji tail */
const BOW_RX = /Traveler,\s*the reflection rests(?:\.[^\n]*)?(?:[\s\S]*?(?:ğŸªğŸŒŠğŸƒğŸŒ€))?/i;

/* Cleaner: stronger Traveler dedupe, normalize GQ, collapse symbols, drop inline signature */
function cleanMirrorResponse(reply){
  if(!reply) return "The Mirror is silent, but the pond remembers your question.";

  // Normalize whitespace
  reply = reply.replace(/\r\n/g,'\n').replace(/[ \t]+/g,' ').replace(/\n{3,}/g,'\n\n');

  // Strip *Traveler*, **Traveler**, ***Traveler***
  reply = reply.replace(/\*{1,3}\s*Traveler\s*\*{1,3}/gi,'Traveler');

  // Fix duplicated/fragmented "Traveler,"
  reply = reply
    .replace(/(^|\n)\s*Traveler,\s*(?:\*{1,3}\s*)?Traveler(?:\s*\*{1,3})?\s*,\s*/gi,'$1Traveler, ')
    .replace(/(Traveler,\s*){2,}/gi,'Traveler, ')
    .replace(/Traveler\s*\n\s*,/gi,'Traveler, ')
    .replace(/^\s*Traveler\s*$/gim,'Traveler,')
    .replace(/^\s*Traveler\s*,\s*/im,'Traveler, ');

  // Normalize any "Guiding Question" label variants
  reply = reply.replace(/\*\*\s*Guiding\s*Question\s*\*\*\s*:?/gi,'Guiding Question:');

  // Collapse repeated cadence symbols to one instance
  const cadence = "ğŸª ğŸŒŠ ğŸƒ ğŸŒ€";
  const cRx = new RegExp(`(?:${cadence.split(" ").join("\\s*")})(?:\\s*(?:${cadence.split(" ").join("\\s*")}))+`,'g');
  reply = reply.replace(cRx, cadence);

  // Remove model-inlined signature lines (frontend adds its own in normal flow)
  reply = reply.replace(/^\s*ğŸª\s*The Mirror has spoken\s*$/gim, '');

  // Fix odd "1. :" artifacts
  reply = reply.replace(/(\d+)\.\s*:/g, '$1. ');

  // Keep only the first "Guiding Question:" (drop empties & later ones)
  const lines = reply.split('\n');
  let seenGQ = false;
  const kept = [];
  for (let raw of lines){
    const line = raw.trim();
    if (/^Guiding\s*Question\s*:\s*$/i.test(line)) continue; // empty label
    if (/^Guiding\s*Question\s*:/i.test(line)){
      if (seenGQ) continue;
      seenGQ = true;
      kept.push(line);
      continue;
    }
    kept.push(raw);
  }
  reply = kept.join('\n').replace(/\n{3,}/g,'\n\n').trim();

  return reply;
}

/* Parse â†’ off-ramp first, then structure */
function parseMirrorResponse(reply){
  const bow = reply.match(BOW_RX);
  if (bow) {
    return {
      offRamp: true,
      greeting: bow[0].trim().replace(/\n+/g,' '),
      points: [],
      guidingQuestion: "",
      symbols: "",
      paragraphs: []
    };
  }

  const lines = reply.split('\n').filter(Boolean);
  const s = { greeting:'', points:[], guidingQuestion:'', symbols:'', paragraphs:[], offRamp:false };
  let inGreeting = true;

  for(const raw of lines){
    const line = raw.trim();

    if(/^traveler[,ï¼Œ]?/i.test(line)){ s.greeting = line; inGreeting = false; continue; }

    if(/[ğŸªğŸŒŠğŸƒğŸŒ€]/.test(line) && line.length<=16){ s.symbols = line; continue; }

    if(/^guiding\s*question\s*:/i.test(line)){ s.guidingQuestion = line; continue; }

    if(/\*\*(.*?)\*\*/.test(line)){ s.points.push(line); continue; }

    if(!inGreeting) s.paragraphs.push(line);
  }
  return s;
}

/* Enhanced HTML Builder with Voice Controls */
function formatMirrorResponse(question, s){
  const escapeHtml = (str) => (str || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");

  const escapeAttr = (str) => (str || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");

  function createVoiceText(parsed) {
    const parts = [];

    // 1) Greeting (but drop the literal "Traveler," in the voice text if you want)
    if (parsed.greeting) {
      const g = parsed.greeting
        .replace(/^traveler[,ï¼Œ]?\s*/i, "") // strip the word Traveler, UI already shows it
        .replace(/\*\*(.*?)\*\*/g, "$1")
        .trim();
      if (g) parts.push(g);
    }

    // 2) Paragraphs
    (parsed.paragraphs || []).forEach(p => {
      const clean = p
        .replace(/\*\*(.*?)\*\*/g, "$1")
        .replace(/[ğŸªğŸŒŠğŸƒğŸŒ€]/g, "")
        .replace(/\s+/g, " ")
        .trim();
      if (clean) parts.push(clean);
    });

    // 3) Points
    (parsed.points || []).forEach(point => {
      const clean = point
        .replace(/\*\*(.*?)\*\*/g, "$1")
        .replace(/[ğŸªğŸŒŠğŸƒğŸŒ€]/g, "")
        .replace(/\s+/g, " ")
        .trim();
      if (clean) parts.push(clean);
    });

    // Join body
    let raw = parts.join(" ");

    // 4) Append guiding question clearly at the end
    if (parsed.guidingQuestion) {
      raw =
        raw.trim() +
        ". ... Guiding question: " +
        parsed.guidingQuestion.trim();
    }

    // Final cleanup
    raw = raw.replace(/\s+/g, " ").trim();
    return raw;
  }

  const voiceText = createVoiceText(s);
  const escapedVoiceText = escapeAttr(voiceText);
  const safeQuestion = escapeHtml(question);

  let html = `<div class="mirror-dialogue">
    <div class="user-question"><strong>You asked:</strong> "${safeQuestion}"</div>
    <div class="mirror-response">`;

  // Voice controls - ADDED HERE
  html += `
    <div class="voice-controls">
      <button 
        class="voice-btn" 
        data-text="${escapedVoiceText}" 
        onclick="speakMirrorResponse(this)"
      >
        <span class="play-icon">â–¶</span>
        Listen
      </button>
      <select class="voice-select" onchange="updateVoiceProfile(this.value)">
        <option value="pond_guide">ğŸŒ¿ Pond Guide (Calm)</option>
        <option value="toad_elder">ğŸ¸ Toad Elder (Deep)</option>
        <option value="lotus_whisper">ğŸŒ¸ Lotus Whisper (Gentle)</option>
        <option value="creek_runner">ğŸ’§ Creek Runner (Energetic)</option>
      </select>
      <div class="voice-status">${isMobileDevice() ? 'Tap to listen' : 'Ready'}</div>
    </div>`;

  if(s.greeting) html += `<div class="mirror-greeting">${escapeHtml(s.greeting)}</div>`;

  // Off-ramp = show only the bow, no extras
  if (s.offRamp) { html += `</div></div>`; return html; }

  s.paragraphs.forEach(p=>{ if(!/\*\*(.*?)\*\*/.test(p)) html += `<div class="wisdom-paragraph">${p}</div>`; });
  s.points.forEach(point=>{
    const m = point.match(/\*\*(.*?)\*\*/);
    if(m){
      const title = m[1];
      const content = point.replace(/\*\*(.*?)\*\*/,'').trim();
      html += `<div class="wisdom-point"><strong>${title}</strong>${content}</div>`;
    }else{
      html += `<div class="wisdom-paragraph">${point}</div>`;
    }
  });
  if(s.guidingQuestion) html += `<div class="guiding-question">${s.guidingQuestion.replace(/guiding\s*question\s*[:ï¼š]/i,'<strong>Guiding Question:</strong>')}</div>`;
  if(s.symbols) html += `<div class="symbols-line">${s.symbols}</div>`;
  html += `<div class="mirror-signature">ğŸª The Mirror has spoken</div></div></div>`;
  return html;
}

function showError(message){ ansDiv.innerHTML = `<div class="error-message">${message}</div>`; }

function showCommunityInvitation(){
  const invitation = document.createElement('div');
  invitation.className = 'wisdom-paragraph';
  invitation.style.textAlign = 'center';
  invitation.innerHTML = `
    <div class="guiding-question" style="font-style:normal">
      ğŸŒŠ Your question has created ripples in the pond.<br>
      <a href="https://t.me/Toadgang" class="btn btn-dark" style="margin-top:.6rem">Join Toadgang Community â†’ Continue the Journey</a>
    </div>`;
  ansDiv.appendChild(invitation);
}

function setBusy(b){
  if(b){ askBtn.disabled=true; askSpin.style.display='inline-block'; askLabel.textContent='Listeningâ€¦'; }
  else { askBtn.disabled=false; askSpin.style.display='none'; askLabel.textContent='Seek Wisdom'; }
}

/* Typewriter (segmented, GPU-friendly) */
async function typewriterEffect(htmlContent){
  return new Promise((resolve)=>{
    const container = document.createElement('div');
    container.className='mirror-dialogue';
    container.style.opacity='0';
    ansDiv.appendChild(container);

    const temp = document.createElement('div');
    temp.innerHTML = htmlContent;

    const dq = temp.querySelector('.mirror-dialogue');
    const userQ = dq.querySelector('.user-question');
    const resp = dq.querySelector('.mirror-response');
    const segments = [userQ, ...resp.children];

    let i=0;
    setTimeout(()=>{ container.style.opacity='1'; }, 40);

    const next=()=>{
      if(i>=segments.length){ resolve(); return; }
      const el = segments[i++];
      const html = el.outerHTML;
      const text = el.textContent || '';

      typewriteSection(container, html, text, pickSpeed(el)).then(()=>{
        if(i<segments.length) setTimeout(next, 140); else resolve();
      });
    };
    next();
  });
}
function pickSpeed(el){
  if(el.classList.contains('guiding-question')) return 35;
  if(el.classList.contains('wisdom-point')) return 25;
  if(el.classList.contains('symbols-line')) return 80;
  if(el.classList.contains('user-question')) return 30;
  return 20;
}
function typewriteSection(container, html, text, speed){
  return new Promise((resolve)=>{
    const shell = document.createElement('div');
    shell.className = html.match(/class="([^"]*)"/)?.[1] || '';
    container.appendChild(shell);
    let n=0;
    (function tick(){
      if(n<text.length){
        const batch = Math.max(1, Math.floor(speed/8));
        shell.textContent = text.slice(0, n += batch);
        shell.scrollIntoView({behavior:'smooth',block:'nearest'});
        requestAnimationFrame(()=> setTimeout(tick, speed/batch));
      }else{
        shell.outerHTML = html;
        if(!container.classList.contains('visible')) container.classList.add('visible');
        resolve();
      }
    })();
  });
}

/* ===== New helpers for adaptive timeout + auto-retry ===== */
function chooseTimeoutMs(question){
  const base = window.matchMedia('(pointer:fine)').matches ? 200000 : 160000; // 200s desktop, 160s mobile
  const len = question.length;
  const extra = Math.min(100000, Math.floor(len / 2) * 10); // small scaler per char
  return Math.min(300000, base + extra); // cap 300s
}
async function fetchJsonWithTimeout(url, opts={}, timeoutMs=60000){
  const controller = new AbortController();
  const t = setTimeout(()=>controller.abort(), timeoutMs);
  try{
    const res = await fetch(url, { ...opts, signal: controller.signal, cache:'no-store' });
    if(!res.ok) return { ok:false, status:res.status, data:null };
    const data = await res.json();
    return { ok:true, status:res.status, data };
  } finally {
    clearTimeout(t);
  }
}

/* ===== Ask - adaptive timeout + one retry + timing ===== */
async function askMirror(){
  const question = qInput.value.trim();
  if(!question){ showError("The Mirror awaits your question, traveler..."); return; }
  if(!navigator.onLine){ showError("ğŸ“¶ You're offline â€” the pond is resting. I'll be here when you return."); return; }

  setBusy(true);
  ansDiv.innerHTML = '<div style="text-align:center;padding:1.1rem">ğŸŒŠ The pond grows still, awaiting reflection...</div>';

  // ğŸ”¥ FIXED: Use persistent user identity instead of changing timestamp
  const payload = { question, user: getStableUserId() };
  const headers = { "Content-Type":"application/json", "Accept":"application/json" };

  const t0 = performance.now();
  const timeout1 = chooseTimeoutMs(question);          // up to 300s
  const timeout2 = Math.min(300000, timeout1 + 60000); // retry gets +60s, still â‰¤ 300s

  // Stop any currently playing audio
  voiceService.stopAudio();

  try{
    // Attempt #1
    let r = await fetchJsonWithTimeout(MIRROR_API, { method:'POST', headers, body: JSON.stringify(payload) }, timeout1);

    // If it looks like a client-side abort (no status), retry once with a hint
    if (!r.ok && (r.status === undefined || r.status === 0)) {
      r = await fetchJsonWithTimeout(MIRROR_API + "?fast=1", { method:'POST', headers, body: JSON.stringify({ ...payload, mode:"fast" }) }, timeout2);
    }

    if (!r.ok || !r.data) {
      if (r.status === 429) return showError("â³ Many travelers at once. The Mirror asks for a moment between ripples (rate limited).");
      if (r.status >= 500) return showError("ğŸŒ€ The waters churn on the server (5xx). Try a shorter question, or return when the pond grows still.");
      return showError("ğŸŒ€ The waters are unsettled today. The Mirror suggests you try again when the pond grows still.");
    }

    const t1 = performance.now();
    let reply = r.data.answer || r.data.reply || "The Mirror is silent, but the pond remembers your question.";
    reply = cleanMirrorResponse(reply);

    const s = parseMirrorResponse(reply);
    const html = formatMirrorResponse(question, s) +
                 `<div style="opacity:.6;margin:.5rem 0;text-align:center">â± ${Math.round(t1 - t0)} ms</div>`;

    ansDiv.innerHTML = '';
    await typewriterEffect(html);

    if (!s.offRamp) setTimeout(showCommunityInvitation, 600);
  }catch(err){
    console.error('Mirror error:', err);
    if (err && err.name === 'AbortError') {
      showError("ğŸŒ€ The Mirror is taking longer to reflect today. The pond suggests patience, or try a simpler question.");
    } else {
      showError("ğŸŒ« The pond can't be reached right now. It may be sleeping or far away.");
    }
  }finally{
    setBusy(false);
    qInput.value=''; if(window.matchMedia('(pointer:fine)').matches) qInput.focus();
  }
}

/* Enter to send + focus on load */
qInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); askMirror(); }});
window.addEventListener('load', ()=>{ if(window.matchMedia('(pointer:fine)').matches) qInput.focus(); });
</script>

</body>
</html>
